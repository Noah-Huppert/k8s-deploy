package gzip

import (
	"archive/tar"
	"bytes"
	"compress/gzip"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	//	"time"
)

// ArchiveDir gzips a directory
// SO answer used to figure out the flow of creating a tar.gz file:
//	https://stackoverflow.com/questions/38454850/getting-write-too-long-error-when-trying-to-create-tar-gz-file-from-file-and-d#
func ArchiveDir(dir string) (*bytes.Buffer, error) {
	// Create gzip archive
	var archiveBuffer bytes.Buffer
	archive := gzip.NewWriter(&archiveBuffer)

	/*
		archive.Name = "docker-build-context.gzip"
		archive.Comment = "generated by gzip.ArchiveDir function"
		archive.ModTime = time.Now()
	*/

	// Create tar file
	tarBall := tar.NewWriter(archive)

	// Add all files in directory to tar ball
	files, err := ioutil.ReadDir(dir)
	if err != nil {
		return nil, fmt.Errorf("error listing files in directory \"%s\": %s",
			dir, err.Error())
	}

	for _, file := range files {
		// If directory skip
		if file.IsDir() {
			continue
		}

		name := file.Name()

		// Write file header to tar ball
		header, err := tar.FileInfoHeader(file, name)
		if err != nil {
			return nil, fmt.Errorf("error creating tar file header for "+
				"\"%s\": %s", err.Error())
		}

		err = tarBall.WriteHeader(header)
		if err != nil {
			return nil, fmt.Errorf("error writing file header for \"%s\""+
				"to tar ball: %s", name, err.Error())
		}

		// Open file
		filePntr, err := os.Open(name)
		if err != nil {
			return nil, fmt.Errorf("error opening file \"%s\": %s",
				name, err.Error())
		}

		// Copy file to tar ball
		_, err = io.Copy(tarBall, filePntr)
		if err != nil {
			return nil, fmt.Errorf("error copying file \"%s\" into tar "+
				"ball: %s", name, err.Error())
		}

		// Close file
		err = filePntr.Close()
		if err != nil {
			return nil, fmt.Errorf("error closing file  \"%s\": %s",
				name, err.Error())
		}
	}

	// Finish writing tar ball
	err = tarBall.Close()
	if err != nil {
		return nil, fmt.Errorf("error closing tar ball: %s", err.Error())
	}

	// Finish archiving
	err = archive.Close()
	if err != nil {
		return nil, fmt.Errorf("error closing archive: %s", err.Error())
	}

	return &archiveBuffer, nil
}
